import torch
import matplotlib.pyplot as plt
from matplotlib.axes import Axes
from matplotlib.gridspec import GridSpecFromSubplotSpec
import numpy as np
from visualize.base import BaseVisualizer
from visualize.data_for_visualization import DataForVisualization


class GaussMarkerVisualizer(BaseVisualizer):
    """GaussMarker watermark visualization class"""

    def __init__(self, data_for_visualization: DataForVisualization, dpi: int = 300, watermarking_step: int = -1):
        super().__init__(data_for_visualization, dpi, watermarking_step)

    # ------------------------------------------------------------------
    # Helper utilities
    # ------------------------------------------------------------------
    def _get_boolean_mask(self) -> torch.Tensor:
        mask = self.data.watermarking_mask
        if mask.dtype == torch.bool:
            return mask
        return mask != 0

    def _resolve_channels(self, mask: torch.Tensor, requested_channel: int | None = None) -> list[int]:
        if mask.dim() == 3:
            mask = mask.unsqueeze(0)
        num_channels = mask.shape[1]

        if requested_channel is not None:
            if requested_channel < 0 or requested_channel >= num_channels:
                raise ValueError(f"Channel {requested_channel} is out of range. Max channel: {num_channels - 1}")
            return [requested_channel]

        default_channel = getattr(self.data, "w_channel", -1)
        if default_channel not in (-1, None):
            if default_channel < 0 or default_channel >= num_channels:
                raise ValueError(f"w_channel {default_channel} is out of range. Max channel: {num_channels - 1}")
            return [int(default_channel)]

        mask_flat = mask.view(mask.shape[0], mask.shape[1], -1).any(dim=-1)
        active_channels = [idx for idx, flag in enumerate(mask_flat[0].tolist()) if flag]
        if not active_channels:
            return list(range(num_channels))
        return active_channels

    def _grid_shape(self, count: int) -> tuple[int, int]:
        rows = int(np.ceil(np.sqrt(count)))
        cols = int(np.ceil(count / rows))
        return rows, cols

    def _get_reversed_latent(self, step: int | None = None) -> torch.Tensor:
        reversed_series = self.data.reversed_latents
        if isinstance(reversed_series, (list, tuple)):
            total = len(reversed_series)
            index = self.watermarking_step if step is None else step
            if index < 0:
                index = total + index
            index = max(0, min(total - 1, index))
            return reversed_series[index]
        return reversed_series

    def _prepare_watermark_tensor(self) -> torch.Tensor:
        generator = self.data.watermark_generator
        watermark = generator.watermark_tensor().to(torch.float32)
        if watermark.dim() == 3:
            watermark = watermark.unsqueeze(0)
        return watermark.cpu()

    # ------------------------------------------------------------------
    # Bit-level visualizations
    # ------------------------------------------------------------------
    def draw_watermark_bits(
        self,
        channel: int | None = None,
        title: str = "Original Watermark Bits",
        cmap: str = "binary",
        ax: Axes | None = None,
    ) -> Axes:
        """Visualize the original watermark bits generated by GaussMarker."""

        watermark = self._prepare_watermark_tensor()
        num_channels = watermark.shape[1]

        if channel is not None:
            if channel < 0 or channel >= num_channels:
                raise ValueError(f"Channel {channel} is out of range. Max channel: {num_channels - 1}")
            channels = [channel]
        else:
            channels = list(range(num_channels))

        if len(channels) == 1:
            ch = channels[0]
            if ch >= num_channels:
                raise ValueError(f"Channel {ch} is out of range. Max channel: {num_channels - 1}")
            data = watermark[0, ch].cpu().numpy()
            im = ax.imshow(data, cmap=cmap, vmin=0, vmax=1, interpolation="nearest")
            if title != "":
                ax.set_title(f"{title} - Channel {ch}", fontsize=10)
            ax.axis('off')
            cbar = ax.figure.colorbar(im, ax=ax, alpha=0.0)
            cbar.ax.set_visible(False)
        else:
            ax.clear()
            if title != "":
                ax.set_title(title, pad=20)
            ax.axis('off')

            rows, cols = self._grid_shape(len(channels))
            gs = GridSpecFromSubplotSpec(rows, cols, subplot_spec=ax.get_subplotspec(), wspace=0.3, hspace=0.4)
            for i, ch in enumerate(channels):
                if ch >= num_channels:
                    raise ValueError(f"Channel {ch} is out of range. Max channel: {num_channels - 1}")
                row_idx = i // cols
                col_idx = i % cols
                sub_ax = ax.figure.add_subplot(gs[row_idx, col_idx])
                data = watermark[0, ch].cpu().numpy()
                im = sub_ax.imshow(data, cmap=cmap, vmin=0, vmax=1, interpolation="nearest")
                sub_ax.set_title(f'Channel {ch}', fontsize=8, pad=3)
                sub_ax.axis('off')
                cbar = ax.figure.colorbar(im, ax=sub_ax, fraction=0.046, pad=0.04)
                cbar.ax.tick_params(labelsize=6)

        return ax

    def draw_reconstructed_watermark_bits(
        self,
        channel: int | None = None,
        step: int | None = None,
        title: str = "Reconstructed Watermark Bits",
        cmap: str = "binary",
        ax: Axes | None = None,
    ) -> Axes:
        """Visualize watermark bits reconstructed from inverted latents."""

        reversed_latent = self._get_reversed_latent(step)
        generator = self.data.watermark_generator
        reconstructed = generator.pred_w_from_latent(reversed_latent).to(torch.float32)
        reference = generator.watermark_tensor(reconstructed.device)
        bit_acc = (reconstructed == reference).float().mean().item()

        if reconstructed.dim() == 3:
            reconstructed = reconstructed.unsqueeze(0)

        num_channels = reconstructed.shape[1]

        if channel is not None:
            if channel < 0 or channel >= num_channels:
                raise ValueError(f"Channel {channel} is out of range. Max channel: {num_channels - 1}")
            channels = [channel]
        else:
            channels = list(range(num_channels))

        if len(channels) == 1:
            ch = channels[0]
            if ch >= num_channels:
                raise ValueError(f"Channel {ch} is out of range. Max channel: {num_channels - 1}")
            data = reconstructed[0, ch].cpu().numpy()
            im = ax.imshow(data, cmap=cmap, vmin=0, vmax=1, interpolation="nearest")
            title_text = f"{title} - Channel {ch} (Bit Acc: {bit_acc:.3f})" if title != "" else f"Channel {ch} (Bit Acc: {bit_acc:.3f})"
            ax.set_title(title_text, fontsize=10)
            ax.axis('off')
            cbar = ax.figure.colorbar(im, ax=ax, alpha=0.0)
            cbar.ax.set_visible(False)
        else:
            ax.clear()
            header = f"{title} (Bit Acc: {bit_acc:.3f})" if title != "" else f"(Bit Acc: {bit_acc:.3f})"
            ax.set_title(header, pad=20)
            ax.axis('off')

            rows, cols = self._grid_shape(len(channels))
            gs = GridSpecFromSubplotSpec(rows, cols, subplot_spec=ax.get_subplotspec(), wspace=0.3, hspace=0.4)

            for i, ch in enumerate(channels):
                if ch >= num_channels:
                    raise ValueError(f"Channel {ch} is out of range. Max channel: {num_channels - 1}")
                row_idx = i // cols
                col_idx = i % cols
                sub_ax = ax.figure.add_subplot(gs[row_idx, col_idx])
                data = reconstructed[0, ch].cpu().numpy()
                im = sub_ax.imshow(data, cmap=cmap, vmin=0, vmax=1, interpolation="nearest")
                sub_ax.set_title(f'Channel {ch}', fontsize=8, pad=3)
                sub_ax.axis('off')
                cbar = ax.figure.colorbar(im, ax=sub_ax, fraction=0.046, pad=0.04)
                cbar.ax.tick_params(labelsize=6)

        return ax

    # ------------------------------------------------------------------
    # Frequency-domain visualizations
    # ------------------------------------------------------------------
    def draw_pattern_fft(
        self,
        channel: int | None = None,
        title: str = "GaussMarker Target Pattern (FFT)",
        cmap: str = "viridis",
        use_color_bar: bool = True,
        vmin: float | None = None,
        vmax: float | None = None,
        ax: Axes | None = None,
        **kwargs,
    ) -> Axes:
        """Visualize the intended watermark pattern in the Fourier domain."""

        pattern = self.data.gt_patch
        if pattern.dim() == 3:
            pattern = pattern.unsqueeze(0)
        mask_bool = self._get_boolean_mask()
        if mask_bool.dim() == 3:
            mask_bool = mask_bool.unsqueeze(0)

        channels = self._resolve_channels(mask_bool, channel)
        pattern_abs = torch.abs(pattern).detach().cpu()
        mask_cpu = mask_bool.cpu()

        if len(channels) == 1:
            ch = channels[0]
            amplitude = torch.zeros_like(pattern_abs[0, ch], dtype=torch.float32)
            selection = mask_cpu[0, ch]
            if selection.any():
                amplitude[selection] = pattern_abs[0, ch][selection]
            im = ax.imshow(amplitude.numpy(), cmap=cmap, vmin=vmin, vmax=vmax, **kwargs)
            if title != "":
                ax.set_title(f"{title} - Channel {ch}")
            if use_color_bar:
                cbar = ax.figure.colorbar(im, ax=ax)
                cbar.ax.tick_params(labelsize=8)
            ax.axis('off')
        else:
            ax.clear()
            if title != "":
                ax.set_title(title, pad=20)
            ax.axis('off')

            rows, cols = self._grid_shape(len(channels))
            gs = GridSpecFromSubplotSpec(rows, cols, subplot_spec=ax.get_subplotspec(), wspace=0.3, hspace=0.4)

            for i, ch in enumerate(channels):
                row_idx = i // cols
                col_idx = i % cols
                sub_ax = ax.figure.add_subplot(gs[row_idx, col_idx])
                amplitude = torch.zeros_like(pattern_abs[0, ch], dtype=torch.float32)
                selection = mask_cpu[0, ch]
                if selection.any():
                    amplitude[selection] = pattern_abs[0, ch][selection]
                im = sub_ax.imshow(amplitude.numpy(), cmap=cmap, vmin=vmin, vmax=vmax, **kwargs)
                sub_ax.set_title(f'Channel {ch}', fontsize=8, pad=3)
                sub_ax.axis('off')
                if use_color_bar:
                    cbar = ax.figure.colorbar(im, ax=sub_ax, fraction=0.046, pad=0.04)
                    cbar.ax.tick_params(labelsize=6)

        return ax

    def draw_inverted_pattern_fft(
        self,
        channel: int | None = None,
        step: int | None = None,
        title: str = "Recovered Watermark Pattern (FFT)",
        cmap: str = "viridis",
        use_color_bar: bool = True,
        vmin: float | None = None,
        vmax: float | None = None,
        ax: Axes | None = None,
        **kwargs,
    ) -> Axes:
        """Visualize the recovered watermark region in the Fourier domain."""

        reversed_latent = self._get_reversed_latent(step)
        fft_latents = torch.fft.fftshift(torch.fft.fft2(reversed_latent), dim=(-1, -2))
        mask_bool = self._get_boolean_mask()
        if mask_bool.dim() == 3:
            mask_bool = mask_bool.unsqueeze(0)
        channels = self._resolve_channels(mask_bool, channel)

        target_patch = self.data.gt_patch.to(fft_latents.device)
        selection = mask_bool.to(fft_latents.device)
        if selection.sum() > 0:
            complex_l1 = torch.abs(fft_latents - target_patch)[selection].mean().item()
        else:
            complex_l1 = 0.0

        fft_abs = torch.abs(fft_latents).detach().cpu()
        mask_cpu = mask_bool.cpu()

        title_suffix = f" (L1: {complex_l1:.3e})"

        if len(channels) == 1:
            ch = channels[0]
            amplitude = torch.zeros_like(fft_abs[0, ch], dtype=torch.float32)
            selection = mask_cpu[0, ch]
            if selection.any():
                amplitude[selection] = fft_abs[0, ch][selection]
            im = ax.imshow(amplitude.numpy(), cmap=cmap, vmin=vmin, vmax=vmax, **kwargs)
            if title != "":
                ax.set_title(f"{title} - Channel {ch}{title_suffix}")
            elif title_suffix:
                ax.set_title(title_suffix.strip(), fontsize=10)
            if use_color_bar:
                cbar = ax.figure.colorbar(im, ax=ax)
                cbar.ax.tick_params(labelsize=8)
            ax.axis('off')
        else:
            ax.clear()
            if title != "":
                ax.set_title(f"{title}{title_suffix}", pad=20)
            else:
                ax.set_title(title_suffix.strip(), pad=20)
            ax.axis('off')

            rows, cols = self._grid_shape(len(channels))
            gs = GridSpecFromSubplotSpec(rows, cols, subplot_spec=ax.get_subplotspec(), wspace=0.3, hspace=0.4)

            for i, ch in enumerate(channels):
                row_idx = i // cols
                col_idx = i % cols
                sub_ax = ax.figure.add_subplot(gs[row_idx, col_idx])
                amplitude = torch.zeros_like(fft_abs[0, ch], dtype=torch.float32)
                selection = mask_cpu[0, ch]
                if selection.any():
                    amplitude[selection] = fft_abs[0, ch][selection]
                im = sub_ax.imshow(amplitude.numpy(), cmap=cmap, vmin=vmin, vmax=vmax, **kwargs)
                sub_ax.set_title(f'Channel {ch}', fontsize=8, pad=3)
                sub_ax.axis('off')
                if use_color_bar:
                    cbar = ax.figure.colorbar(im, ax=sub_ax, fraction=0.046, pad=0.04)
                    cbar.ax.tick_params(labelsize=6)

        return ax

    def draw_watermark_mask(
        self,
        channel: int | None = None,
        title: str = "Watermark Mask",
        cmap: str = "viridis",
        ax: Axes | None = None,
    ) -> Axes:
        """Visualize the spatial region where the watermark is applied."""

        mask_bool = self._get_boolean_mask()
        if mask_bool.dim() == 3:
            mask_bool = mask_bool.unsqueeze(0)
        channels = self._resolve_channels(mask_bool, channel)
        mask_cpu = mask_bool.float().cpu()

        if len(channels) == 1:
            ch = channels[0]
            data = mask_cpu[0, ch].numpy()
            im = ax.imshow(data, cmap=cmap, vmin=0, vmax=1)
            if title != "":
                ax.set_title(f"{title} - Channel {ch}")
            cbar = ax.figure.colorbar(im, ax=ax, alpha=0.0)
            cbar.ax.set_visible(False)
            ax.axis('off')
        else:
            ax.clear()
            if title != "":
                ax.set_title(title, pad=20)
            ax.axis('off')

            rows, cols = self._grid_shape(len(channels))
            gs = GridSpecFromSubplotSpec(rows, cols, subplot_spec=ax.get_subplotspec(), wspace=0.3, hspace=0.4)

            for i, ch in enumerate(channels):
                row_idx = i // cols
                col_idx = i % cols
                sub_ax = ax.figure.add_subplot(gs[row_idx, col_idx])
                data = mask_cpu[0, ch].numpy()
                im = sub_ax.imshow(data, cmap=cmap, vmin=0, vmax=1)
                sub_ax.set_title(f'Channel {ch}', fontsize=8, pad=3)
                sub_ax.axis('off')
                cbar = ax.figure.colorbar(im, ax=sub_ax, fraction=0.046, pad=0.04)
                cbar.ax.tick_params(labelsize=6)

        return ax